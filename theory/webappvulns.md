# Web Application Vulnerabilities
[Home](../index.md) | [CheatSheets](../cheatsheets.md) | [Theory](../theory.md) | [About](../about.md) | [Back](../theory.md)

<details>
<summary>JWT (JSON Web Tokens)</summary>
  
  ### JWT Background:
  JWTs serve as an alternative to traditional session management and contain information about users. They are used for authentication, session handling and  implementing access control mechanisms. Unlike session cookies, JWTs store all of the information about the user on the client side which is useful for highly distributed web applications. 
  
  A JWT consists of three parts:
    * Header - Contains metadata about the token itself.
    * Payload - Contains user data and information 
    * Signature - A signature is generated by hashing the header and payload and may also be encrypted.
  
  Each component is a base64url-encoded JSON object separated by dots '.' and can be read by anybody with access to a token using a decoder. Since the data in a JWT can  be easily read and modified by anyone who has access to it, the security of JWTs relies on the presence of a cryptographic signature. 
  
  When a server issues a JWT token a signature is typically generated from the header and payload values. This involves using a secret signing key that is known only by the server and allows the server to verify that the contents of the JWT has not been modified. Since the signature is generated from the header and payload, changing any part of the JWT will result in a signature mismatch, it should be impossible to generate the correct signature for a given header and payload without knowing the secret signing key. 

  A JWT is either implemented as a JWS (JSON Web Signature) or JWE (JSON Web Encryption), these specifications define how a JWT should be implemented in practice. In most cases, people refering to JWTs are actually refering to a JWS, a JWE is similar to a JWS except the header and payload contents are encrypted rather than encoded. 
  
  ### JWT Attack Methods:
  JWT attacks are performed in an attempt to bypass authentication and access control mechanisms, if we are able to steal or forge JWTs, we might be able to perform actions on behalf of another application user and obtain sensitive information. In the worst case scenario, we might be able to elevate our privileges and take full control over user accounts. 
  
  JWT vulnerabilities typically arise due to a mishandling of the token in the application, many specifications for JWTs exist and it is often up to the developer to implement the functionality themselves. This can result in accidental vulnerabilities being introduced even if libraries are used to harden the application environment. JWT vulnerabilties are commonly found in the way the JWT signature is verified, if the server fails to properly verify a JWT signature, an attacker might be able to tamper with the values that are passed to the application via the payload field. In addition, the integrity of a JWT lies entirely on the assumption that the secret signing key remains secret, if this key is guessable via bruteforce or is leaked in some other way for example through a LFI attack, an attacker could generate a valid signature for any token. 
  
  ### Exploiting JWT Signature Verification:
  The application server does not store any information about the JWTs that it issues by design, instead each token is a self contained entity. This design provides many benefits for developers and applications but introduces a different problem, how does the server know about the original contents of the token that it issued? If the server fails to verify the signature correctly, an attacker can make arbitrary changes to the token. 
  
  Consider this example JWT token:
  
  ```
  { 
    "username": "john",
    "userType": "user"
  }
  ```
  If the server uses the username name/value pair to identify which user account to display and signature verification is flawed, an attacker could change the value to any user they wish and take over their account. Similarly, if the value of the userType name/value pair was changed to "admin", an attacker might be able to access administration functionality.
  
  ### Accepting Arbitrary Signatures:
  JWT code libraries typically provide two methods for handling tokens, one method will verify the token and the other will simply decode the token. The Node.js jsonwebtoken library provides the methods verify() for verifying the tokens signature and decode() for decoding the JWT, it could be the case that in the implementation of the JWT functionality, the developer(s) passed the token only to the decode() method and not to the verify() method beforehand. This means that the application does not perform any signature validation at all before returning application data to the user.
  
  If the server fails to validate the signature in this way, we could try changing the values in the payload section to other users or administrative usernames in an attempt to access restricted parts of the application. To do this, modify the payload values in a JWT editor such as the one provided in burpsuite and replace your token with the one you modified. If the server does not perform any signature validation you might be able to access restricted parts of the application such as user other user accounts, administration portals, etc. Remember, if the server does not perform any signature validation you won't need to change the signature of the JWT in anyway just the payload values. 
  
  ### Removing the Signature:
  The JWT header contains a parameter called 'alg' which informs the server which algorithm was used to sign the token. This is used by the server when validating the signature since it needs to know which algorithm to use to regenerate the signature from the given token:
  
  ```
  {
    "alg": "HS256",
    "typ": "JWT"
  }
  . . . . . . . . . . .
  {
    "alg": "none",
    "typ": "JWT"
   }
  ```
  
  Since JWTs are stored on the client side we can also tamper with the values specified in the header component of the token. JWTs can use different signing algorithms such as HS256 but they can also be left unsigned. If this is the case, the value of the 'alg' name/value pair can be set to 'none' which indicates an insecure JWT. Typically servers will reject tokens with no signature but this is typically done through string validation, it is sometimes possible to bypass these validation checks by using character obfuscation techniques such as character encoding or random capitalization. 
  
  It is important to note that even if a JWT is unsigned it must still contain a trailing dot '.' 
</details>
